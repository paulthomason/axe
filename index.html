<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Axe Throwing Challenge</title>
  <style>
    body {
      background: #f6f6f8;
      min-height: 100vh;
      margin: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    h1 {
      text-align: center;
      margin-top: 32px;
      margin-bottom: 12px;
      font-size: 2.4rem;
      letter-spacing: 2px;
    }
    #gameWrapper {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }
    #gameCanvas {
      width: 100%;
      aspect-ratio: 4 / 3;
      display: block;
      background: #fff;
      box-shadow: 0 6px 30px rgba(80,80,100,0.13);
      border-radius: 10px;
      border: 1.5px solid #b0b0c0;
    }
    #nameOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #nameBox {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      text-align: center;
    }
    #nameBox input {
      padding: 8px;
      font-size: 1rem;
    }
    #nameBox button {
      margin-left: 8px;
      padding: 8px 16px;
      font-size: 1rem;
    }
    #instructions {
      margin: 20px auto 0;
      max-width: 650px;
      text-align: center;
      color: #222;
      font-size: 1.08rem;
      letter-spacing: .5px;
    }
    #tapButton {
      margin-top: 20px;
      padding: 16px 32px;
      font-size: 1.6rem;
      background: #4caf58;
      color: #fff;
      border: none;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    #bulletButton {
      margin-top: 12px;
      padding: 14px 28px;
      font-size: 1.4rem;
      background: #000;
      color: #0f0;
      font-family: 'Courier New', Courier, monospace;
      border: 2px solid #0f0;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    #multiButton {
      margin-top: 12px;
      padding: 14px 28px;
      font-size: 1.4rem;
      background: #222;
      color: #ff0;
      font-family: 'Courier New', Courier, monospace;
      border: 2px solid #ff0;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    #lockButton {
      margin-top: 12px;
      padding: 14px 28px;
      font-size: 1.4rem;
      background: #014;
      color: #0ff;
      font-family: 'Courier New', Courier, monospace;
      border: 2px solid #0ff;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    #lockPrompt {
      position: absolute;
      top: 50px;
      right: 10px;
      padding: 6px 12px;
      font-size: 1.6rem;
      background: #fff;
      color: #000;
      border: 2px solid #000;
      font-family: 'Courier New', Courier, monospace;
      border-radius: 6px;
      display: none;
    }
    #restartButton {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 16px;
      font-size: 1rem;
      display: none;
    }
    #debugConsole {
      width: 90%;
      max-width: 800px;
      height: 120px;
      margin: 20px auto 0;
      padding: 8px;
      background: #1e1e1e;
      color: #0f0;
      font-family: monospace;
      font-size: 0.85rem;
      overflow-y: auto;
      white-space: pre-wrap;
      display: none;
    }
    @media (max-width: 850px) {
      #gameCanvas { width: 97vw; }
    }
  </style>
</head>
<body>
  <h1>Axe Throwing Challenge</h1>
  <div id="gameWrapper">
    <button id="restartButton">Restart</button>
    <div id="lockPrompt"></div>
    <canvas id="gameCanvas"></canvas>
    <div id="nameOverlay">
      <div id="nameBox">
        <label for="nameInput">Who do you want to throw axes at?</label><br>
        <input id="nameInput" type="text" placeholder="Enter a name" />
        <button id="nameSubmit">Start</button>
      </div>
    </div>
  </div>
  <button id="tapButton">Tap</button>
  <button id="bulletButton">BULLET TIME</button>
  <button id="multiButton">AXE BARRAGE</button>
  <button id="lockButton">LOCK IN</button>
  <div id="instructions">
    Use <b>SPACEBAR</b> or <span id="touchInstruction">tap the button below</span> to lock each slider and throw. Use the BULLET TIME button once per game to slow the sliders. Use the AXE BARRAGE button once to unleash five random throws. Use the LOCK IN button once for a chance at three perfect hits.
  </div>
  <div id="debugConsole"></div>
  <script>
  // ==== Constants ====
  let CANVAS_WIDTH = 800, CANVAS_HEIGHT = 600;

  // Target (bullseye)
  let TARGET_X = CANVAS_WIDTH / 2;
  let TARGET_Y = CANVAS_HEIGHT / 3;
  let TARGET_RADIUS_OUTERMOST = 135;
  let TARGET_RADIUS_OUTER = 100;
  let TARGET_RADIUS_MIDDLE = 65;
  let TARGET_RADIUS_INNER = 30;

  // Axe
  let AXE_START_X = CANVAS_WIDTH / 2;
  let AXE_START_Y = CANVAS_HEIGHT - 100;
  const DESIRED_AXE_SPRITE_HEIGHT = 55;
  // Approximate distance from axe center to the tip of the metal blade
  const AXE_BLADE_OFFSET = DESIRED_AXE_SPRITE_HEIGHT * 0.25;
  // Distance from axe center to the middle of the blade cutting edge
  const AXE_BLADE_CENTER_OFFSET = DESIRED_AXE_SPRITE_HEIGHT * 0.20;

  function updateCanvasConstants() {
    CANVAS_WIDTH = canvas.width;
    CANVAS_HEIGHT = canvas.height;
    TARGET_X = CANVAS_WIDTH / 2;
    TARGET_Y = CANVAS_HEIGHT / 3;
    AXE_START_X = CANVAS_WIDTH / 2;
    AXE_START_Y = CANVAS_HEIGHT - 100;
    const base = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT);
    TARGET_RADIUS_OUTERMOST = base * 0.225;
    TARGET_RADIUS_OUTER = base * 0.167;
    TARGET_RADIUS_MIDDLE = base * 0.108;
    TARGET_RADIUS_INNER = base * 0.05;
    AIM_SLIDER_LENGTH = TARGET_RADIUS_OUTERMOST * 2 * 1.3;
    POWER_SLIDER_LENGTH = TARGET_RADIUS_OUTERMOST * 2;
  }

  // Sliders
  // Aiming sliders extend past the target width for added challenge
  let AIM_SLIDER_LENGTH = TARGET_RADIUS_OUTERMOST * 2 * 1.3; // 30% longer than the target diameter
  let POWER_SLIDER_LENGTH = TARGET_RADIUS_OUTERMOST * 2;      // unchanged for power control
  const SLIDER_THICKNESS = 20;
  const SLIDER_MARKER_W = 10, SLIDER_MARKER_H = 30;
  const SLIDER_MARKER_L = 30, SLIDER_MARKER_T = 4;

  // Slider speeds (px/sec)
  const HORIZ_SLIDER_SPEED = 240; // increased for higher difficulty
  const VERT_SLIDER_SPEED = 180;  // increased for higher difficulty
  const POWER_SLIDER_SPEED = 300; // increased for higher difficulty
  const POWER_SPEED_INCREASE_SCALE = 0.7; // lessens power meter acceleration
  const AXE_ROTATION_SPEED = 400 * Math.PI / 180; // rad/sec

  // Colors
  const COLOR_OUTERMOST = "#d8b373"; // outermost ring
  const COLOR_OUTER = "#c7965c";    // outer ring
  const COLOR_MIDDLE = "#b07845";   // middle ring
  const COLOR_INNER = "#e53636";    // bullseye
  const DARK_WOOD_BROWN = "#704e2e";

  // States
  const STATE_LOADING           = 0;
  const STATE_AIM_HORIZONTAL    = 1;
  const STATE_AIM_VERTICAL      = 2;
  const STATE_AIM_POWER         = 3;
  const STATE_THROWING          = 4;
  const STATE_SHOWING_RESULT    = 5;
  const STATE_GAME_OVER         = 6;
  const STATE_LOCK_CHALLENGE    = 7;

  // Power
  // POWER_IDEAL controls how the selected power affects vertical accuracy.
  // Scoring is always based on where the axe lands regardless of power.
  const POWER_IDEAL = 0.65;

  // Misc
  const RESULT_SHOW_TIME = 2000; // ms

  // ==== Globals ====
  let canvas, ctx, bulletButtonEl, multiButtonEl, lockButtonEl, lockPromptEl, restartButtonEl, debugConsoleEl;
  let targetName = '';

  let state = STATE_LOADING;

  // Asset management
  let axeImageRaw = null, axeImageScaled = null, axeImageOk = false;
  let assetsToLoad = 1;
  let assetsLoaded = 0;
  let assetLoadErrorAxe = false;

  // Game
  let score = 0;
  let highScore = 0;
  let lastThrowMissed = false;
  let lives = 3;
  let consecutiveBullseyes = 0;
  let currentThrowIsMulti = false;
  let resultMsg = '', resultPoints = 0;
  let showResultTimer = 0;

  // Aiming/Sliders
  let horizontalSliderPos = 0; // 0...1
  let verticalSliderPos = 0;
  let powerSliderPos = 0;
  let horizSliderDir = 1;
  let vertSliderDir = 1;
  let powerSliderDir = 1;
  // Multiplier for slider speeds that increases when the player scores
  let sliderSpeedMultiplier = 1;
  let bulletTimeAvailable = true;
  let multiThrowAvailable = true;
  let lockInAvailable = true;
  let lockInActive = false;
  let lockLetters = [];
  let lockIndex = 0;
  let lockTimer = 0;
  let lockQueue = 0;
  let bulletTimeActive = false;
  let bulletTimeFactor = 1;
  let gameStarted = false;
  let locked_horizontal_offset = 0;
  let locked_vertical_offset = 0;
  let locked_power_normalized = 0;

  // Multi-throw tracking
  let multiAxes = [];

  // Throw
  let axeIsFlying = false;
  let axeThrowProgress = 0; // 0...1
  let axeAngle = 0;
  let axeThrowDuration = 0.68; // sec
  let axeTargetX = TARGET_X, axeTargetY = TARGET_Y;
  let axeHitX = TARGET_X, axeHitY = TARGET_Y;

  // Offset from axe center to the exact blade tip used for scoring (computed
  // after the sprite is scaled)
  let axeTipOffsetX = 0;
  let axeTipOffsetY = 0;

  // For random offset/accuracy
  let throw_random_dx = 0, throw_random_dy = 0;

  function initDebugConsole() {
    if (!debugConsoleEl) return;
    window.addEventListener('error', e => {
      logDebug(`Error: ${e.message} at ${e.filename}:${e.lineno}`);
    });
    window.addEventListener('unhandledrejection', e => {
      logDebug(`Unhandled rejection: ${e.reason}`);
    });
    const origError = console.error;
    console.error = function(...args) {
      origError.apply(console, args);
      logDebug('Console error: ' + args.join(' '));
    };
  }

  function logDebug(msg) {
    if (!debugConsoleEl) return;
    debugConsoleEl.style.display = 'block';
    const div = document.createElement('div');
    div.textContent = msg;
    debugConsoleEl.appendChild(div);
    debugConsoleEl.scrollTop = debugConsoleEl.scrollHeight;
  }

  // ----

  window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    debugConsoleEl = document.getElementById('debugConsole');
    initDebugConsole();
    const nameOverlayEl = document.getElementById('nameOverlay');
    const nameInputEl = document.getElementById('nameInput');
    const nameSubmitEl = document.getElementById('nameSubmit');

    function applyName() {
      if (nameInputEl.value.trim()) targetName = nameInputEl.value.trim();
      nameOverlayEl.style.display = 'none';
      nameInputEl.removeEventListener('keydown', nameKeyHandler);
      gameStarted = true;
      if (bulletButtonEl) bulletButtonEl.style.display = 'block';
      if (multiButtonEl && multiThrowAvailable) multiButtonEl.style.display = 'block';
      if (lockButtonEl && lockInAvailable) lockButtonEl.style.display = 'block';
      if (restartButtonEl) restartButtonEl.style.display = 'block';
    }
    function nameKeyHandler(e) {
      if (e.key === 'Enter') applyName();
    }
    nameSubmitEl.addEventListener('click', applyName);
    nameInputEl.addEventListener('keydown', nameKeyHandler);
    nameInputEl.focus();
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    updateCanvasConstants();
    window.addEventListener('resize', () => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      updateCanvasConstants();
    });
    const tapButtonEl = document.getElementById('tapButton');
    bulletButtonEl = document.getElementById('bulletButton');
    multiButtonEl = document.getElementById('multiButton');
    lockButtonEl = document.getElementById('lockButton');
    lockPromptEl = document.getElementById('lockPrompt');
    const restartButtonEl = document.getElementById('restartButton');
    const touchInstructionEl = document.getElementById('touchInstruction');

    highScore = parseInt(getCookie('highScore')) || 0;

    const isTouchOnly = navigator.maxTouchPoints > 0 && !window.matchMedia('(any-hover: hover)').matches;

    window.addEventListener('keydown', handleInput);

    function triggerTap(e) {
      e.preventDefault(); // prevent 300ms click delay and synthetic click
      if (!gameStarted) return;
      handleInput({ code: 'Space', preventDefault: function(){} });
    }

    if (isTouchOnly) {
      tapButtonEl.style.display = 'block';
      tapButtonEl.addEventListener('touchstart', triggerTap);
      tapButtonEl.addEventListener('click', triggerTap);
      if (touchInstructionEl) touchInstructionEl.textContent = 'tap the button below';
    } else {
      window.addEventListener('touchstart', triggerTap);
      window.addEventListener('click', triggerTap);
      if (touchInstructionEl) touchInstructionEl.textContent = 'click anywhere on the screen';
    }

    if (bulletTimeAvailable) {
      function bulletBtnHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!gameStarted) return;
        activateBulletTime();
      }
      bulletButtonEl.addEventListener('click', bulletBtnHandler);
      bulletButtonEl.addEventListener('touchstart', bulletBtnHandler);
    }

    if (multiThrowAvailable) {
      function multiBtnHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!gameStarted || !multiThrowAvailable) return;
        performMultiThrow();
        if (multiButtonEl) multiButtonEl.style.display = 'none';
      }
      multiButtonEl.addEventListener('click', multiBtnHandler);
      multiButtonEl.addEventListener('touchstart', multiBtnHandler);
    }

    if (lockInAvailable) {
      function lockBtnHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!gameStarted || !lockInAvailable) return;
        startLockInChallenge();
        if (lockButtonEl) lockButtonEl.style.display = 'none';
      }
      lockButtonEl.addEventListener('click', lockBtnHandler);
      lockButtonEl.addEventListener('touchstart', lockBtnHandler);
    }

    function restartHandler(e) {
      e.preventDefault();
      e.stopPropagation();
      resetGame();
      state = STATE_AIM_HORIZONTAL;
    }
    restartButtonEl.addEventListener('click', restartHandler);
    restartButtonEl.addEventListener('touchstart', restartHandler);

    // Start loading assets
    loadImages();
    requestAnimationFrame(gameLoop);
  };

  // ==== Asset Loading & Processing ====
  function loadImages() {
    // Load axe.png
    axeImageRaw = new Image();
    axeImageRaw.onload = () => {
      // Scale to DESIRED_AXE_SPRITE_HEIGHT, aspect correct
      const aspect = axeImageRaw.width / axeImageRaw.height;
      const scaledW = Math.round(DESIRED_AXE_SPRITE_HEIGHT * aspect);
      axeImageScaled = document.createElement('canvas');
      axeImageScaled.width = scaledW;
      axeImageScaled.height = DESIRED_AXE_SPRITE_HEIGHT;
      const axectx = axeImageScaled.getContext('2d');
      axectx.drawImage(axeImageRaw, 0, 0, scaledW, DESIRED_AXE_SPRITE_HEIGHT);

      // Compute the tip offset within the scaled sprite based on the known
      // coordinates of the blade point in the original image.
      const TIP_RAW_X = 750.13;
      const TIP_RAW_Y = 351.68;
      const scaleX = axeImageScaled.width / axeImageRaw.width;
      const scaleY = axeImageScaled.height / axeImageRaw.height;
      axeTipOffsetX = (TIP_RAW_X - axeImageRaw.width / 2) * scaleX;
      axeTipOffsetY = (TIP_RAW_Y - axeImageRaw.height / 2) * scaleY;

      axeImageOk = true;
      assetLoaded();
    };
    axeImageRaw.onerror = () => {
      assetLoadErrorAxe = true;
      assetLoaded();
    };
    axeImageRaw.src = "axe.png";

  }

  function assetLoaded() {
    assetsLoaded++;
    if (assetsLoaded === assetsToLoad) {
      setTimeout(() => {
        resetGame();
        state = STATE_AIM_HORIZONTAL;
      }, 500); // Brief delay for loading message
    }
  }

  // ==== Main Game Loop ====
  let prevTimestamp = 0;
  function gameLoop(timestamp) {
    const deltaTime = Math.min((timestamp - prevTimestamp) / 1000, 0.04) || 0.0167; // Clamp dt
    prevTimestamp = timestamp;

    update(deltaTime);
    draw();

    requestAnimationFrame(gameLoop);
  }

  // ==== Update ====
  function update(dt) {
    switch (state) {
      case STATE_LOADING:
        // Nothing to update
        break;
      case STATE_AIM_HORIZONTAL:
        // Slider moves back and forth automatically
        horizontalSliderPos += horizSliderDir * HORIZ_SLIDER_SPEED * sliderSpeedMultiplier * bulletTimeFactor * dt / AIM_SLIDER_LENGTH;
        if (horizontalSliderPos > 1) { horizontalSliderPos = 1; horizSliderDir = -1; }
        if (horizontalSliderPos < 0) { horizontalSliderPos = 0; horizSliderDir = 1; }
        break;
      case STATE_AIM_VERTICAL:
        verticalSliderPos += vertSliderDir * VERT_SLIDER_SPEED * sliderSpeedMultiplier * bulletTimeFactor * dt / AIM_SLIDER_LENGTH;
        if (verticalSliderPos > 1) { verticalSliderPos = 1; vertSliderDir = -1; }
        if (verticalSliderPos < 0) { verticalSliderPos = 0; vertSliderDir = 1; }
        break;
      case STATE_AIM_POWER:
        const pMult = 1 + (sliderSpeedMultiplier - 1) * POWER_SPEED_INCREASE_SCALE;
        powerSliderPos += powerSliderDir * POWER_SLIDER_SPEED * pMult * bulletTimeFactor * dt / POWER_SLIDER_LENGTH;
        if (powerSliderPos > 1) { powerSliderPos = 1; powerSliderDir = -1; }
        if (powerSliderPos < 0) { powerSliderPos = 0; powerSliderDir = 1; }
        break;
      case STATE_THROWING:
        if (multiAxes.length > 0) {
          let allDone = true;
          for (let i = 0; i < multiAxes.length; i++) {
            const ax = multiAxes[i];
            if (ax.progress < 1) {
              ax.progress += dt * bulletTimeFactor / axeThrowDuration;
              if (ax.progress >= 1) {
                ax.progress = 1;
                const res = evaluateHit(ax.hitX, ax.hitY, ax.angle);
                ax.points = res.points;
                ax.scored = true;
                score += res.points;
                if (res.points > 0) {
                  sliderSpeedMultiplier *= 1.2;
                  lastThrowMissed = false;
                }
                if (score > highScore) {
                  highScore = score;
                  setCookie('highScore', highScore, 365);
                }
              } else {
                allDone = false;
              }
            }
            ax.angle = AXE_ROTATION_SPEED * axeThrowDuration * (ax.progress - 1);
          }
          if (allDone) {
            const total = multiAxes.reduce((s, a) => s + a.points, 0);
            bulletTimeActive = false;
            bulletTimeFactor = 1;
            resultPoints = total;
            resultMsg = total > 0 ? "Barrage!" : "Missed!";
            lastThrowMissed = total === 0;
            consecutiveBullseyes = 0;
            showResultTimer = RESULT_SHOW_TIME;
            state = STATE_SHOWING_RESULT;
          }
        } else if (axeIsFlying) {
          axeThrowProgress += dt * bulletTimeFactor / axeThrowDuration;
          if (axeThrowProgress >= 1.0) {
            axeThrowProgress = 1.0;
            axeIsFlying = false;
            evaluateThrow();
          }
          axeAngle = AXE_ROTATION_SPEED * axeThrowDuration * (axeThrowProgress - 1);
        }
        break;
      case STATE_SHOWING_RESULT:
        showResultTimer -= dt * 1000;
        if (showResultTimer <= 0) {
          if (lockQueue > 0) {
            resetForNextThrow();
            startBullseyeThrow();
          } else if (lastThrowMissed) {
            if (!currentThrowIsMulti) lives--;
            if (lives <= 0) {
              state = STATE_GAME_OVER;
            } else {
              state = STATE_AIM_HORIZONTAL;
              resetForNextThrow();
            }
          } else {
            state = STATE_AIM_HORIZONTAL;
            resetForNextThrow();
          }
        }
        break;
      case STATE_LOCK_CHALLENGE:
        lockTimer -= dt * 1000;
        if (lockTimer <= 0) failLockChallenge();
        break;
      case STATE_GAME_OVER:
        // Wait for user to press Space to reset
        break;
    }
  }

  // ==== Draw ====
  function draw() {
    // Clear
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // UI: Score and throws
    ctx.save();
    ctx.font = "26px Segoe UI, Arial";
    ctx.fillStyle = "#e13b3b";
    ctx.textAlign = "left";
    for (let i=0; i<lives; i++) {
      ctx.fillText("♥", 22 + i*28, 36);
    }
    ctx.font = "22px Segoe UI, Arial";
    ctx.fillStyle = "#1a1a1d";
    ctx.fillText("Score: " + score, 22, 64);
    ctx.fillText("High: " + highScore, 22, 88);
    ctx.restore();

    // Center target
    drawTarget();

    // Draw sliders
    if (state === STATE_AIM_HORIZONTAL) drawHorizontalSlider();
    if (state === STATE_AIM_VERTICAL) drawVerticalSlider();
    if (state === STATE_AIM_POWER) drawPowerSlider();

    // Draw axe
    if (state === STATE_AIM_HORIZONTAL || state === STATE_AIM_VERTICAL || state === STATE_AIM_POWER) {
      drawAxeSprite(AXE_START_X, AXE_START_Y, 0);
    }
    else if (state === STATE_THROWING || state === STATE_SHOWING_RESULT || state === STATE_GAME_OVER) {
      drawFlyingAxes();
    }

    // Overlay messages
    switch (state) {
      case STATE_LOADING:
        ctx.save();
        ctx.font = "32px Segoe UI, Arial";
        ctx.fillStyle = "#233";
        ctx.textAlign = "center";
        ctx.fillText("Loading Assets...", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 35);
        ctx.restore();
        break;
      case STATE_SHOWING_RESULT:
        ctx.save();
        ctx.font = "34px Segoe UI, Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#212122";
        ctx.fillText(resultMsg, CANVAS_WIDTH/2, 470);
        ctx.font = "24px Segoe UI, Arial";
        ctx.fillText("+" + resultPoints + " points", CANVAS_WIDTH/2, 510);
        ctx.restore();
        break;
      case STATE_LOCK_CHALLENGE:
        break;
      case STATE_GAME_OVER:
        ctx.save();
        ctx.font = "40px Segoe UI, Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#bf2b2b";
        ctx.fillText("GAME OVER", CANVAS_WIDTH/2, 420);
        ctx.font = "28px Segoe UI, Arial";
        ctx.fillStyle = "#222";
        ctx.fillText("Final Score: " + score, CANVAS_WIDTH/2, 470);
        ctx.fillText("High Score: " + highScore, CANVAS_WIDTH/2, 510);
        ctx.font = "22px Segoe UI, Arial";
        ctx.fillText("Press Space to Play Again!", CANVAS_WIDTH/2, 550);
        ctx.restore();
        break;
    }
  }

  // ==== Drawing Functions ====

  function drawTarget() {
    // Outermost ring
    ctx.save();
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_OUTERMOST, 0, Math.PI*2);
    ctx.fillStyle = COLOR_OUTERMOST;
    ctx.fill();
    ctx.lineWidth = 5;
    ctx.strokeStyle = DARK_WOOD_BROWN;
    ctx.stroke();

    // Outer ring
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_OUTER, 0, Math.PI*2);
    ctx.fillStyle = COLOR_OUTER;
    ctx.fill();
    ctx.lineWidth = 5;
    ctx.strokeStyle = DARK_WOOD_BROWN;
    ctx.stroke();

    // Middle ring
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_MIDDLE, 0, Math.PI*2);
    ctx.fillStyle = COLOR_MIDDLE;
    ctx.fill();
    ctx.strokeStyle = DARK_WOOD_BROWN;
    ctx.stroke();

    // Inner ring
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_INNER, 0, Math.PI*2);
    ctx.fillStyle = COLOR_INNER;
    ctx.fill();

    ctx.lineWidth = 2.5;
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_INNER, 0, Math.PI*2);
    ctx.stroke();

    // Crosshairs
    ctx.lineWidth = 1.8;
    ctx.strokeStyle = "#222";
    ctx.beginPath();
    ctx.moveTo(TARGET_X - TARGET_RADIUS_OUTERMOST - 15, TARGET_Y);
    ctx.lineTo(TARGET_X + TARGET_RADIUS_OUTERMOST + 15, TARGET_Y);
    ctx.moveTo(TARGET_X, TARGET_Y - TARGET_RADIUS_OUTERMOST - 15);
    ctx.lineTo(TARGET_X, TARGET_Y + TARGET_RADIUS_OUTERMOST + 15);
    ctx.stroke();

    // Center text
    ctx.font = "bold 24px Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.fillText(targetName, TARGET_X, TARGET_Y);

    // Score numbers
    ctx.font = "bold 20px Segoe UI, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#000";
    const LABEL_OFFSET_X = 20;
    ctx.fillText("3", TARGET_X + LABEL_OFFSET_X, TARGET_Y - (TARGET_RADIUS_OUTERMOST + TARGET_RADIUS_OUTER)/2);
    ctx.fillText("5", TARGET_X + LABEL_OFFSET_X, TARGET_Y - (TARGET_RADIUS_OUTER + TARGET_RADIUS_MIDDLE)/2);
    ctx.fillText("7", TARGET_X + LABEL_OFFSET_X, TARGET_Y - (TARGET_RADIUS_MIDDLE + TARGET_RADIUS_INNER)/2);
    ctx.restore();
  }

  function drawAxeSprite(x, y, angleRad) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angleRad);
    if (axeImageOk && axeImageScaled) {
      ctx.drawImage(
        axeImageScaled,
        -axeImageScaled.width/2,
        -axeImageScaled.height/2
      );
    } else {
      // Draw fallback axe: handle (brown rect), head (grey rect)
      ctx.save();
      // Handle
      ctx.fillStyle = "#9c7a3c";
      ctx.fillRect(-4, 10, 8, 30);
      // Head
      ctx.fillStyle = "#aaa";
      ctx.fillRect(-13, -8, 26, 16);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#555";
      ctx.strokeRect(-13, -8, 26, 16);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawFlyingAxe() {
    // If throwing, interpolate
    let t = axeThrowProgress;
    // Start pos
    let sx = AXE_START_X, sy = AXE_START_Y;
    // Target pos (landing point, includes random offset)
    let ex = axeHitX, ey = axeHitY;

    // Parabolic arc (arc_height, so flight is not a straight line)
    let arc_height = 120 + 20 * Math.abs(locked_power_normalized - POWER_IDEAL);

    let x = sx + (ex - sx) * t;
    let y = sy + (ey - sy) * t - arc_height * Math.sin(Math.PI * t);

    drawAxeSprite(x, y, axeAngle);
  }

  function drawFlyingAxes() {
    if (multiAxes.length === 0) {
      drawFlyingAxe();
      return;
    }
    multiAxes.forEach(ax => {
      let t = ax.progress;
      let sx = AXE_START_X, sy = AXE_START_Y;
      let ex = ax.hitX, ey = ax.hitY;
      let arc = 120 + 20 * Math.abs(ax.power - POWER_IDEAL);
      let x = sx + (ex - sx) * t;
      let y = sy + (ey - sy) * t - arc * Math.sin(Math.PI * t);
      drawAxeSprite(x, y, ax.angle);
    });
  }

  function drawHorizontalSlider() {
    // Centered below target
    const sx = TARGET_X - AIM_SLIDER_LENGTH/2;
    const sy = TARGET_Y + TARGET_RADIUS_OUTERMOST + 40;

    // Slider bar
    ctx.save();
    ctx.fillStyle = "#2a85ea";
    ctx.fillRect(sx, sy, AIM_SLIDER_LENGTH, SLIDER_THICKNESS);

    // Marker (red vertical bar)
    let mx = sx + horizontalSliderPos * AIM_SLIDER_LENGTH - SLIDER_MARKER_W/2;
    ctx.fillStyle = "#e13b3b";
    ctx.fillRect(mx, sy - (SLIDER_MARKER_H-SLIDER_THICKNESS)/2, SLIDER_MARKER_W, SLIDER_MARKER_H);

    // Outline
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#134292";
    ctx.strokeRect(sx, sy, AIM_SLIDER_LENGTH, SLIDER_THICKNESS);
    ctx.restore();
  }

  function drawVerticalSlider() {
    // To left of target, vertically centered
    const sx = TARGET_X - TARGET_RADIUS_OUTERMOST - 40 - SLIDER_THICKNESS;
    const sy = TARGET_Y - AIM_SLIDER_LENGTH/2;

    ctx.save();
    ctx.fillStyle = "#2a85ea";
    ctx.fillRect(sx, sy, SLIDER_THICKNESS, AIM_SLIDER_LENGTH);

    // Marker (red horizontal line)
    let my = sy + verticalSliderPos * AIM_SLIDER_LENGTH;
    ctx.fillStyle = "#e13b3b";
    ctx.fillRect(sx - (SLIDER_MARKER_L - SLIDER_THICKNESS)/2, my - SLIDER_MARKER_T/2, SLIDER_MARKER_L, SLIDER_MARKER_T);

    // Outline
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#134292";
    ctx.strokeRect(sx, sy, SLIDER_THICKNESS, AIM_SLIDER_LENGTH);
    ctx.restore();
  }

  function drawPowerSlider() {
    // To right of target, vertically centered
    const sx = TARGET_X + TARGET_RADIUS_OUTERMOST + 40;
    const sy = TARGET_Y - POWER_SLIDER_LENGTH/2;

    ctx.save();
    // Background bar
    ctx.fillStyle = "#d9d9dd";
    ctx.fillRect(sx, sy, SLIDER_THICKNESS, POWER_SLIDER_LENGTH);

    // Zones for color coding (entire meter)
    const zones = [
      { start: 0.0, end: 0.35, color: "#e13b3b" },  // red
      { start: 0.35, end: 0.5, color: "#ffd93d" }, // yellow
      { start: 0.5, end: 0.8, color: "#4caf58" },  // green
      { start: 0.8, end: 0.95, color: "#ffd93d" }, // yellow
      { start: 0.95, end: 1.0, color: "#e13b3b" }  // red
    ];

    // Draw color segments across the full slider length
    zones.forEach(zone => {
      const segHeight = POWER_SLIDER_LENGTH * (zone.end - zone.start);
      const segY = sy + POWER_SLIDER_LENGTH * (1 - zone.end);
      ctx.fillStyle = zone.color;
      ctx.fillRect(sx, segY, SLIDER_THICKNESS, segHeight);
    });

    // Marker (blue horizontal line with white outline for visibility)
    const my = sy + POWER_SLIDER_LENGTH * (1 - powerSliderPos);
    const markX = sx - (SLIDER_MARKER_L - SLIDER_THICKNESS) / 2;
    const markY = my - SLIDER_MARKER_T / 2;
    ctx.fillStyle = "#134292";
    ctx.fillRect(markX, markY, SLIDER_MARKER_L, SLIDER_MARKER_T);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#fff";
    ctx.strokeRect(markX, markY, SLIDER_MARKER_L, SLIDER_MARKER_T);

    // Outline
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#999";
    ctx.strokeRect(sx, sy, SLIDER_THICKNESS, POWER_SLIDER_LENGTH);
    ctx.restore();
  }

  function activateBulletTime() {
    if (!bulletTimeAvailable || bulletTimeActive) return;
    bulletTimeAvailable = false;
    bulletTimeActive = true;
    bulletTimeFactor = 0.2;
    if (bulletButtonEl) bulletButtonEl.style.display = 'none';
  }

  function performMultiThrow() {
    if (!multiThrowAvailable) return;
    currentThrowIsMulti = true;
    multiThrowAvailable = false;
    multiAxes = [];
    for (let i = 0; i < 5; i++) {
      const hOff = (Math.random() - 0.5) * 2 * TARGET_RADIUS_OUTERMOST;
      const vOff = (Math.random() - 0.5) * 2 * TARGET_RADIUS_OUTERMOST;
      const power = Math.random();

      const angle = -AXE_ROTATION_SPEED * axeThrowDuration;
      const powerEffect = (POWER_IDEAL - power) * (TARGET_RADIUS_OUTERMOST * 2.0);
      const targetX = TARGET_X + hOff;
      const targetY = TARGET_Y + vOff + powerEffect;
      let powerAcc = 1.0 - Math.abs(power - POWER_IDEAL) / POWER_IDEAL;
      powerAcc = Math.max(0, powerAcc);
      const maxRand = 18 * (1.0 - powerAcc ** 2);
      const randX = (Math.random() - 0.5) * 2 * maxRand;
      const randY = (Math.random() - 0.5) * 2 * maxRand;
      const hitX = targetX + randX;
      const hitY = targetY + randY;

      multiAxes.push({
        power,
        targetX,
        targetY,
        hitX,
        hitY,
        angle,
        progress: 0,
        scored: false,
        points: 0,
      });
    }
    state = STATE_THROWING;
  }

  function startLockInChallenge() {
    if (!lockInAvailable || lockInActive) return;
    lockInAvailable = false;
    lockInActive = true;
    lockLetters = [];
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (let i = 0; i < 5; i++) {
      const ch = letters[Math.floor(Math.random() * letters.length)];
      lockLetters.push(ch);
    }
    lockIndex = 0;
    lockTimer = 1500;
    state = STATE_LOCK_CHALLENGE;
    if (lockPromptEl) {
      lockPromptEl.textContent = lockLetters[lockIndex];
      lockPromptEl.style.display = 'block';
    }
    window.addEventListener('keydown', lockKeyHandler);
  }

  function lockKeyHandler(e) {
    const k = e.key.toUpperCase();
    if (k === lockLetters[lockIndex]) {
      lockIndex++;
      if (lockIndex >= lockLetters.length) {
        succeedLockChallenge();
      } else {
        lockTimer = 1500;
        if (lockPromptEl) lockPromptEl.textContent = lockLetters[lockIndex];
      }
    } else {
      failLockChallenge();
    }
  }

  function failLockChallenge() {
    window.removeEventListener('keydown', lockKeyHandler);
    if (lockPromptEl) lockPromptEl.style.display = 'none';
    lockInActive = false;
    state = STATE_AIM_HORIZONTAL;
  }

  function succeedLockChallenge() {
    window.removeEventListener('keydown', lockKeyHandler);
    if (lockPromptEl) lockPromptEl.style.display = 'none';
    lockInActive = false;
    lockQueue = 3;
    state = STATE_AIM_HORIZONTAL;
    resetForNextThrow();
    startBullseyeThrow();
  }

  function startBullseyeThrow() {
    if (lockQueue <= 0) return;
    lockQueue--;
    locked_horizontal_offset = 0;
    locked_vertical_offset = 0;
    locked_power_normalized = POWER_IDEAL;
    startThrow();
  }

  // ==== Input ====
  function handleInput(e) {
    if (!gameStarted) return;
    if (state === STATE_LOCK_CHALLENGE) return;
    if (e.code === 'Space') {
      e.preventDefault();
      switch (state) {
        case STATE_AIM_HORIZONTAL:
          // Lock horizontal offset
          locked_horizontal_offset =
            (horizontalSliderPos - 0.5) * 2 * TARGET_RADIUS_OUTERMOST;
          state = STATE_AIM_VERTICAL;
          break;
        case STATE_AIM_VERTICAL:
          // Lock vertical offset
          locked_vertical_offset =
            (verticalSliderPos - 0.5) * 2 * TARGET_RADIUS_OUTERMOST;
          state = STATE_AIM_POWER;
          break;
        case STATE_AIM_POWER:
          // Lock power, throw!
          locked_power_normalized = powerSliderPos;
          startThrow();
          break;
          case STATE_SHOWING_RESULT:
            if (lastThrowMissed) {
              if (!currentThrowIsMulti) lives--;
              if (lives <= 0) {
                state = STATE_GAME_OVER;
              } else {
                state = STATE_AIM_HORIZONTAL;
                resetForNextThrow();
              }
            } else {
              state = STATE_AIM_HORIZONTAL;
              resetForNextThrow();
            }
            break;
        case STATE_GAME_OVER:
          resetGame();
          state = STATE_AIM_HORIZONTAL;
          break;
      }
    }
  }

  // ==== Throwing Logic ====
  function startThrow() {
    state = STATE_THROWING;
    currentThrowIsMulti = false;
    axeIsFlying = true;
    axeThrowProgress = 0;
    axeAngle = -AXE_ROTATION_SPEED * axeThrowDuration;

    // Compute target for this throw
    // (Ideal power = minimal vertical deviation. Too low: drop below. Too high: overshoot upward)
    let power_effect_factor = (POWER_IDEAL - locked_power_normalized) * (TARGET_RADIUS_OUTERMOST * 2.0);

    axeTargetX = TARGET_X + locked_horizontal_offset;
    axeTargetY = TARGET_Y + locked_vertical_offset + power_effect_factor;

    // Accuracy: randomness increases as power deviates from ideal
    let power_accuracy_modifier = 1.0 - Math.abs(locked_power_normalized - POWER_IDEAL)/POWER_IDEAL;
    power_accuracy_modifier = Math.max(0, power_accuracy_modifier); // Clamp
    let max_rand = 18 * (1.0 - power_accuracy_modifier**2); // up to 18px if far from ideal
    throw_random_dx = (Math.random()-0.5) * 2 * max_rand;
    throw_random_dy = (Math.random()-0.5) * 2 * max_rand;

    axeHitX = axeTargetX + throw_random_dx;
    axeHitY = axeTargetY + throw_random_dy;
  }

  function evaluateHit(hitX, hitY, angle) {
    const rotX = axeTipOffsetX * Math.cos(angle) -
                 axeTipOffsetY * Math.sin(angle);
    const rotY = axeTipOffsetX * Math.sin(angle) +
                 axeTipOffsetY * Math.cos(angle);
    const tipX = hitX + rotX;
    const tipY = hitY + rotY;
    let dx = tipX - TARGET_X;
    let dy = tipY - TARGET_Y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    let msg = "Missed!";
    let points = 0;
    if (dist <= TARGET_RADIUS_INNER) {
      msg = "Bullseye!";
      points = 10;
    } else if (dist <= TARGET_RADIUS_MIDDLE) {
      msg = "Great Shot!";
      points = 7;
    } else if (dist <= TARGET_RADIUS_OUTER) {
      msg = "On Target!";
      points = 5;
    } else if (dist <= TARGET_RADIUS_OUTERMOST) {
      msg = "Close!";
      points = 3;
    }
    return {msg, points};
  }

  function evaluateThrow() {
    const {msg, points} = evaluateHit(axeHitX, axeHitY, axeAngle);
    resultMsg = msg;
    resultPoints = points;
    if (resultPoints > 0) {
      score += resultPoints;
      if (score > highScore) {
        highScore = score;
        setCookie('highScore', highScore, 365);
      }
    }
    if (resultPoints > 0) {
      sliderSpeedMultiplier *= 1.2;
      lastThrowMissed = false;
      if (resultPoints === 10) {
        consecutiveBullseyes++;
        if (consecutiveBullseyes >= 3) {
          lives++;
          consecutiveBullseyes = 0;
        }
      } else {
        consecutiveBullseyes = 0;
      }
    } else {
      lastThrowMissed = true;
      consecutiveBullseyes = 0;
    }

    bulletTimeActive = false;
    bulletTimeFactor = 1;

    showResultTimer = lockQueue > 0 ? 600 : RESULT_SHOW_TIME;
    state = STATE_SHOWING_RESULT;
  }

  // ==== Utilities ====

  function resetGame() {
    score = 0;
    resultMsg = '';
    lives = 3;
    consecutiveBullseyes = 0;
    resultPoints = 0;
    sliderSpeedMultiplier = 1;
    bulletTimeAvailable = true;
    multiThrowAvailable = true;
    lockInAvailable = true;
    lockQueue = 0;
    bulletTimeActive = false;
    bulletTimeFactor = 1;
    if (bulletButtonEl) bulletButtonEl.style.display = 'block';
    if (multiButtonEl) multiButtonEl.style.display = 'block';
    if (lockButtonEl) lockButtonEl.style.display = 'block';
    if (restartButtonEl) restartButtonEl.style.display = 'block';
    lastThrowMissed = false;
    resetForNextThrow();
  }
  function resetForNextThrow() {
    horizontalSliderPos = Math.random();
    verticalSliderPos = Math.random();
    powerSliderPos = Math.random();
    horizSliderDir = Math.random() < 0.5 ? 1 : -1;
    vertSliderDir = Math.random() < 0.5 ? 1 : -1;
    powerSliderDir = Math.random() < 0.5 ? 1 : -1;
    locked_horizontal_offset = 0;
    locked_vertical_offset = 0;
    locked_power_normalized = 0;
    axeIsFlying = false;
    axeThrowProgress = 0;
    axeAngle = 0;
    currentThrowIsMulti = false;
    axeHitX = TARGET_X;
    axeHitY = TARGET_Y;
    lastThrowMissed = false;
    multiAxes = [];
    if (lockPromptEl) lockPromptEl.style.display = 'none';
  }

  function getCookie(name) {
    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    return match ? decodeURIComponent(match[2]) : null;
  }

  function setCookie(name, value, days) {
    let expires = '';
    if (days) {
      const date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      expires = '; expires=' + date.toUTCString();
    }
    document.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/';
  }
</script>
<script type="module">
  import vader from 'https://cdn.skypack.dev/vader-sentiment';
  const { SentimentIntensityAnalyzer } = vader;
  const scores = SentimentIntensityAnalyzer.polarity_scores(
    'VADER works in the browser!'
  );
  console.log(scores);
</script>
</body>
</html>
