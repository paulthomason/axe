<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Axe Throwing Challenge</title>
  <style>
    body {
      background: #f6f6f8;
      min-height: 100vh;
      margin: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    h1 {
      text-align: center;
      margin-top: 32px;
      margin-bottom: 12px;
      font-size: 2.4rem;
      letter-spacing: 2px;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      box-shadow: 0 6px 30px rgba(80,80,100,0.13);
      border-radius: 10px;
      border: 1.5px solid #b0b0c0;
    }
    #instructions {
      margin: 20px auto 0;
      max-width: 650px;
      text-align: center;
      color: #222;
      font-size: 1.08rem;
      letter-spacing: .5px;
    }
    #tapButton {
      margin-top: 20px;
      padding: 16px 32px;
      font-size: 1.6rem;
      background: #4caf58;
      color: #fff;
      border: none;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    #bulletButton {
      margin-top: 12px;
      padding: 14px 28px;
      font-size: 1.4rem;
      background: #000;
      color: #0f0;
      font-family: 'Courier New', Courier, monospace;
      border: 2px solid #0f0;
      border-radius: 8px;
      display: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    @media (max-width: 850px) {
      #gameCanvas { width: 97vw; height: 72vw; max-width:800px; max-height:600px; }
    }
  </style>
</head>
<body>
  <h1>Axe Throwing Challenge</h1>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <button id="tapButton">Tap</button>
  <button id="bulletButton">BULLET TIME</button>
  <div id="instructions">
    Use <b>SPACEBAR</b> or <span id="touchInstruction">tap the button below</span> to lock each slider and throw. Use the BULLET TIME button once per game to slow the sliders.
  </div>
<script>
  // ==== Constants ====
  const CANVAS_WIDTH = 800, CANVAS_HEIGHT = 600;

  // Target (bullseye)
  const TARGET_X = CANVAS_WIDTH / 2;
  const TARGET_Y = CANVAS_HEIGHT / 3;
  const TARGET_RADIUS_OUTER = 100;
  const TARGET_RADIUS_MIDDLE = 65;
  const TARGET_RADIUS_INNER = 30;

  // Axe
  const AXE_START_X = CANVAS_WIDTH / 2;
  const AXE_START_Y = CANVAS_HEIGHT - 100;
  const DESIRED_AXE_SPRITE_HEIGHT = 55;
  // Approximate distance from axe center to the tip of the metal blade
  const AXE_BLADE_OFFSET = DESIRED_AXE_SPRITE_HEIGHT * 0.25;
  // Distance from axe center to the middle of the blade cutting edge
  const AXE_BLADE_CENTER_OFFSET = DESIRED_AXE_SPRITE_HEIGHT * 0.20;

  // Sliders
  // Aiming sliders extend past the target width for added challenge
  const AIM_SLIDER_LENGTH = TARGET_RADIUS_OUTER * 2 * 1.3; // 30% longer than the target diameter
  const POWER_SLIDER_LENGTH = TARGET_RADIUS_OUTER * 2;      // unchanged for power control
  const SLIDER_THICKNESS = 20;
  const SLIDER_MARKER_W = 10, SLIDER_MARKER_H = 30;
  const SLIDER_MARKER_L = 30, SLIDER_MARKER_T = 4;

  // Slider speeds (px/sec)
  const HORIZ_SLIDER_SPEED = 240; // increased for higher difficulty
  const VERT_SLIDER_SPEED = 180;  // increased for higher difficulty
  const POWER_SLIDER_SPEED = 300; // increased for higher difficulty
  const AXE_ROTATION_SPEED = 400 * Math.PI / 180; // rad/sec

  // Colors
  const WOOD_BROWN = "#c28853";
  const DARK_WOOD_BROWN = "#704e2e";

  // States
  const STATE_LOADING           = 0;
  const STATE_AIM_HORIZONTAL    = 1;
  const STATE_AIM_VERTICAL      = 2;
  const STATE_AIM_POWER         = 3;
  const STATE_THROWING          = 4;
  const STATE_SHOWING_RESULT    = 5;
  const STATE_GAME_OVER         = 6;

  // Power
  // POWER_IDEAL controls how the selected power affects vertical accuracy.
  // Scoring is always based on where the axe lands regardless of power.
  const POWER_IDEAL = 0.65;

  // Misc
  const RESULT_SHOW_TIME = 2000; // ms

  // ==== Globals ====
  let canvas, ctx, bulletButtonEl;

  let state = STATE_LOADING;

  // Asset management
  let axeImageRaw = null, axeImageScaled = null, axeImageOk = false;
  let assetsToLoad = 1;
  let assetsLoaded = 0;
  let assetLoadErrorAxe = false;

  // Game
  let score = 0;
  let lastThrowMissed = false;
  let resultMsg = '', resultPoints = 0;
  let showResultTimer = 0;

  // Aiming/Sliders
  let horizontalSliderPos = 0; // 0...1
  let verticalSliderPos = 0;
  let powerSliderPos = 0;
  let horizSliderDir = 1;
  let vertSliderDir = 1;
  let powerSliderDir = 1;
  // Multiplier for slider speeds that increases when the player scores
  let sliderSpeedMultiplier = 1;
  let bulletTimeAvailable = true;
  let bulletTimeActive = false;
  let bulletTimeFactor = 1;
  let locked_horizontal_offset = 0;
  let locked_vertical_offset = 0;
  let locked_power_normalized = 0;

  // Throw
  let axeIsFlying = false;
  let axeThrowProgress = 0; // 0...1
  let axeAngle = 0;
  let axeThrowDuration = 0.68; // sec
  let axeTargetX = TARGET_X, axeTargetY = TARGET_Y;
  let axeHitX = TARGET_X, axeHitY = TARGET_Y;

  // Offset from axe center to the exact blade tip used for scoring (computed
  // after the sprite is scaled)
  let axeTipOffsetX = 0;
  let axeTipOffsetY = 0;

  // For random offset/accuracy
  let throw_random_dx = 0, throw_random_dy = 0;

  // ----

  window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    const tapButtonEl = document.getElementById('tapButton');
    bulletButtonEl = document.getElementById('bulletButton');
    const touchInstructionEl = document.getElementById('touchInstruction');

    const isTouchOnly = navigator.maxTouchPoints > 0 && !window.matchMedia('(any-hover: hover)').matches;

    window.addEventListener('keydown', handleInput);

    function triggerTap(e) {
      e.preventDefault(); // prevent 300ms click delay and synthetic click
      handleInput({ code: 'Space', preventDefault: function(){} });
    }

    if (isTouchOnly) {
      tapButtonEl.style.display = 'block';
      tapButtonEl.addEventListener('touchstart', triggerTap);
      tapButtonEl.addEventListener('click', triggerTap);
      if (touchInstructionEl) touchInstructionEl.textContent = 'tap the button below';
    } else {
      window.addEventListener('touchstart', triggerTap);
      window.addEventListener('click', triggerTap);
      if (touchInstructionEl) touchInstructionEl.textContent = 'click anywhere on the screen';
    }

    if (bulletTimeAvailable) {
      bulletButtonEl.style.display = 'block';
      function bulletBtnHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        activateBulletTime();
      }
      bulletButtonEl.addEventListener('click', bulletBtnHandler);
      bulletButtonEl.addEventListener('touchstart', bulletBtnHandler);
    }

    // Start loading assets
    loadImages();
    requestAnimationFrame(gameLoop);
  };

  // ==== Asset Loading & Processing ====
  function loadImages() {
    // Load axe.png
    axeImageRaw = new Image();
    axeImageRaw.onload = () => {
      // Scale to DESIRED_AXE_SPRITE_HEIGHT, aspect correct
      const aspect = axeImageRaw.width / axeImageRaw.height;
      const scaledW = Math.round(DESIRED_AXE_SPRITE_HEIGHT * aspect);
      axeImageScaled = document.createElement('canvas');
      axeImageScaled.width = scaledW;
      axeImageScaled.height = DESIRED_AXE_SPRITE_HEIGHT;
      const axectx = axeImageScaled.getContext('2d');
      axectx.drawImage(axeImageRaw, 0, 0, scaledW, DESIRED_AXE_SPRITE_HEIGHT);

      // Compute the tip offset within the scaled sprite based on the known
      // coordinates of the blade point in the original image.
      const TIP_RAW_X = 750.13;
      const TIP_RAW_Y = 351.68;
      const scaleX = axeImageScaled.width / axeImageRaw.width;
      const scaleY = axeImageScaled.height / axeImageRaw.height;
      axeTipOffsetX = (TIP_RAW_X - axeImageRaw.width / 2) * scaleX;
      axeTipOffsetY = (TIP_RAW_Y - axeImageRaw.height / 2) * scaleY;

      axeImageOk = true;
      assetLoaded();
    };
    axeImageRaw.onerror = () => {
      assetLoadErrorAxe = true;
      assetLoaded();
    };
    axeImageRaw.src = "axe.png";

  }

  function assetLoaded() {
    assetsLoaded++;
    if (assetsLoaded === assetsToLoad) {
      setTimeout(() => {
        resetGame();
        state = STATE_AIM_HORIZONTAL;
      }, 500); // Brief delay for loading message
    }
  }

  // ==== Main Game Loop ====
  let prevTimestamp = 0;
  function gameLoop(timestamp) {
    const deltaTime = Math.min((timestamp - prevTimestamp) / 1000, 0.04) || 0.0167; // Clamp dt
    prevTimestamp = timestamp;

    update(deltaTime);
    draw();

    requestAnimationFrame(gameLoop);
  }

  // ==== Update ====
  function update(dt) {
    switch (state) {
      case STATE_LOADING:
        // Nothing to update
        break;
      case STATE_AIM_HORIZONTAL:
        // Slider moves back and forth automatically
        horizontalSliderPos += horizSliderDir * HORIZ_SLIDER_SPEED * sliderSpeedMultiplier * bulletTimeFactor * dt / AIM_SLIDER_LENGTH;
        if (horizontalSliderPos > 1) { horizontalSliderPos = 1; horizSliderDir = -1; }
        if (horizontalSliderPos < 0) { horizontalSliderPos = 0; horizSliderDir = 1; }
        break;
      case STATE_AIM_VERTICAL:
        verticalSliderPos += vertSliderDir * VERT_SLIDER_SPEED * sliderSpeedMultiplier * bulletTimeFactor * dt / AIM_SLIDER_LENGTH;
        if (verticalSliderPos > 1) { verticalSliderPos = 1; vertSliderDir = -1; }
        if (verticalSliderPos < 0) { verticalSliderPos = 0; vertSliderDir = 1; }
        break;
      case STATE_AIM_POWER:
        powerSliderPos += powerSliderDir * POWER_SLIDER_SPEED * sliderSpeedMultiplier * bulletTimeFactor * dt / POWER_SLIDER_LENGTH;
        if (powerSliderPos > 1) { powerSliderPos = 1; powerSliderDir = -1; }
        if (powerSliderPos < 0) { powerSliderPos = 0; powerSliderDir = 1; }
        break;
      case STATE_THROWING:
        if (axeIsFlying) {
          axeThrowProgress += dt / axeThrowDuration;
          if (axeThrowProgress >= 1.0) {
            axeThrowProgress = 1.0;
            axeIsFlying = false;
            evaluateThrow();
          }
          axeAngle = AXE_ROTATION_SPEED * axeThrowDuration * (axeThrowProgress - 1);
        }
        break;
      case STATE_SHOWING_RESULT:
        showResultTimer -= dt * 1000;
        if (showResultTimer <= 0) {
          if (lastThrowMissed) {
            state = STATE_GAME_OVER;
          } else {
            state = STATE_AIM_HORIZONTAL;
            resetForNextThrow();
          }
        }
        break;
      case STATE_GAME_OVER:
        // Wait for user to press Space to reset
        break;
    }
  }

  // ==== Draw ====
  function draw() {
    // Clear
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // UI: Score and throws
    ctx.save();
    ctx.font = "22px Segoe UI, Arial";
    ctx.fillStyle = "#1a1a1d";
    ctx.textAlign = "left";
    ctx.fillText("Score: " + score, 22, 36);
    ctx.restore();

    // Center target
    drawTarget();

    // Draw sliders
    if (state === STATE_AIM_HORIZONTAL) drawHorizontalSlider();
    if (state === STATE_AIM_VERTICAL) drawVerticalSlider();
    if (state === STATE_AIM_POWER) drawPowerSlider();

    // Draw axe
    if (state === STATE_AIM_HORIZONTAL || state === STATE_AIM_VERTICAL || state === STATE_AIM_POWER) {
      drawAxeSprite(AXE_START_X, AXE_START_Y, 0);
    }
    else if (state === STATE_THROWING || state === STATE_SHOWING_RESULT || state === STATE_GAME_OVER) {
      // Animate or show stuck axe
      drawFlyingAxe();
    }

    // Overlay messages
    switch (state) {
      case STATE_LOADING:
        ctx.save();
        ctx.font = "32px Segoe UI, Arial";
        ctx.fillStyle = "#233";
        ctx.textAlign = "center";
        ctx.fillText("Loading Assets...", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 35);
        ctx.restore();
        break;
      case STATE_SHOWING_RESULT:
        ctx.save();
        ctx.font = "34px Segoe UI, Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#212122";
        ctx.fillText(resultMsg, CANVAS_WIDTH/2, 470);
        ctx.font = "24px Segoe UI, Arial";
        ctx.fillText("+" + resultPoints + " points", CANVAS_WIDTH/2, 510);
        ctx.restore();
        break;
      case STATE_GAME_OVER:
        ctx.save();
        ctx.font = "40px Segoe UI, Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#bf2b2b";
        ctx.fillText("GAME OVER", CANVAS_WIDTH/2, 420);
        ctx.font = "28px Segoe UI, Arial";
        ctx.fillStyle = "#222";
        ctx.fillText("Final Score: " + score, CANVAS_WIDTH/2, 470);
        ctx.font = "22px Segoe UI, Arial";
        ctx.fillText("Press Space to Play Again!", CANVAS_WIDTH/2, 510);
        ctx.restore();
        break;
    }
  }

  // ==== Drawing Functions ====

  function drawTarget() {
    // Outer ring
    ctx.save();
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_OUTER, 0, Math.PI*2);
    ctx.fillStyle = WOOD_BROWN;
    ctx.fill();
    ctx.lineWidth = 5;
    ctx.strokeStyle = DARK_WOOD_BROWN;
    ctx.stroke();

    // Middle ring
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_MIDDLE, 0, Math.PI*2);
    ctx.fillStyle = WOOD_BROWN;
    ctx.fill();
    ctx.strokeStyle = DARK_WOOD_BROWN;
    ctx.stroke();

    // Inner ring
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_INNER, 0, Math.PI*2);
    ctx.fillStyle = "#e53636";
    ctx.fill();

    ctx.lineWidth = 2.5;
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    ctx.arc(TARGET_X, TARGET_Y, TARGET_RADIUS_INNER, 0, Math.PI*2);
    ctx.stroke();

    // Crosshairs
    ctx.lineWidth = 1.8;
    ctx.strokeStyle = "#222";
    ctx.beginPath();
    ctx.moveTo(TARGET_X - TARGET_RADIUS_OUTER - 15, TARGET_Y);
    ctx.lineTo(TARGET_X + TARGET_RADIUS_OUTER + 15, TARGET_Y);
    ctx.moveTo(TARGET_X, TARGET_Y - TARGET_RADIUS_OUTER - 15);
    ctx.lineTo(TARGET_X, TARGET_Y + TARGET_RADIUS_OUTER + 15);
    ctx.stroke();

    // Center text
    ctx.font = "bold 24px Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.fillText("Pablo", TARGET_X, TARGET_Y);

    // Score numbers
    ctx.font = "bold 20px Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#000";
    ctx.fillText("5", TARGET_X, TARGET_Y - (TARGET_RADIUS_OUTER + TARGET_RADIUS_MIDDLE)/2);
    ctx.fillText("7", TARGET_X, TARGET_Y - (TARGET_RADIUS_MIDDLE + TARGET_RADIUS_INNER)/2);
    ctx.restore();
  }

  function drawAxeSprite(x, y, angleRad) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angleRad);
    if (axeImageOk && axeImageScaled) {
      ctx.drawImage(
        axeImageScaled,
        -axeImageScaled.width/2,
        -axeImageScaled.height/2
      );
    } else {
      // Draw fallback axe: handle (brown rect), head (grey rect)
      ctx.save();
      // Handle
      ctx.fillStyle = "#9c7a3c";
      ctx.fillRect(-4, 10, 8, 30);
      // Head
      ctx.fillStyle = "#aaa";
      ctx.fillRect(-13, -8, 26, 16);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#555";
      ctx.strokeRect(-13, -8, 26, 16);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawFlyingAxe() {
    // If throwing, interpolate
    let t = axeThrowProgress;
    // Start pos
    let sx = AXE_START_X, sy = AXE_START_Y;
    // Target pos (landing point, includes random offset)
    let ex = axeHitX, ey = axeHitY;

    // Parabolic arc (arc_height, so flight is not a straight line)
    let arc_height = 120 + 20 * Math.abs(locked_power_normalized - POWER_IDEAL);

    let x = sx + (ex - sx) * t;
    let y = sy + (ey - sy) * t - arc_height * Math.sin(Math.PI * t);

    drawAxeSprite(x, y, axeAngle);
  }

  function drawHorizontalSlider() {
    // Centered below target
    const sx = TARGET_X - AIM_SLIDER_LENGTH/2;
    const sy = TARGET_Y + TARGET_RADIUS_OUTER + 40;

    // Slider bar
    ctx.save();
    ctx.fillStyle = "#2a85ea";
    ctx.fillRect(sx, sy, AIM_SLIDER_LENGTH, SLIDER_THICKNESS);

    // Marker (red vertical bar)
    let mx = sx + horizontalSliderPos * AIM_SLIDER_LENGTH - SLIDER_MARKER_W/2;
    ctx.fillStyle = "#e13b3b";
    ctx.fillRect(mx, sy - (SLIDER_MARKER_H-SLIDER_THICKNESS)/2, SLIDER_MARKER_W, SLIDER_MARKER_H);

    // Outline
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#134292";
    ctx.strokeRect(sx, sy, AIM_SLIDER_LENGTH, SLIDER_THICKNESS);
    ctx.restore();
  }

  function drawVerticalSlider() {
    // To left of target, vertically centered
    const sx = TARGET_X - TARGET_RADIUS_OUTER - 40 - SLIDER_THICKNESS;
    const sy = TARGET_Y - AIM_SLIDER_LENGTH/2;

    ctx.save();
    ctx.fillStyle = "#2a85ea";
    ctx.fillRect(sx, sy, SLIDER_THICKNESS, AIM_SLIDER_LENGTH);

    // Marker (red horizontal line)
    let my = sy + verticalSliderPos * AIM_SLIDER_LENGTH;
    ctx.fillStyle = "#e13b3b";
    ctx.fillRect(sx - (SLIDER_MARKER_L - SLIDER_THICKNESS)/2, my - SLIDER_MARKER_T/2, SLIDER_MARKER_L, SLIDER_MARKER_T);

    // Outline
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#134292";
    ctx.strokeRect(sx, sy, SLIDER_THICKNESS, AIM_SLIDER_LENGTH);
    ctx.restore();
  }

  function drawPowerSlider() {
    // To right of target, vertically centered
    const sx = TARGET_X + TARGET_RADIUS_OUTER + 40;
    const sy = TARGET_Y - POWER_SLIDER_LENGTH/2;

    ctx.save();
    // Background bar
    ctx.fillStyle = "#d9d9dd";
    ctx.fillRect(sx, sy, SLIDER_THICKNESS, POWER_SLIDER_LENGTH);

    // Zones for color coding (entire meter)
    const zones = [
      { start: 0.0, end: 0.35, color: "#e13b3b" },  // red
      { start: 0.35, end: 0.5, color: "#ffd93d" }, // yellow
      { start: 0.5, end: 0.8, color: "#4caf58" },  // green
      { start: 0.8, end: 0.95, color: "#ffd93d" }, // yellow
      { start: 0.95, end: 1.0, color: "#e13b3b" }  // red
    ];

    // Draw color segments across the full slider length
    zones.forEach(zone => {
      const segHeight = POWER_SLIDER_LENGTH * (zone.end - zone.start);
      const segY = sy + POWER_SLIDER_LENGTH * (1 - zone.end);
      ctx.fillStyle = zone.color;
      ctx.fillRect(sx, segY, SLIDER_THICKNESS, segHeight);
    });

    // Marker (blue horizontal line with white outline for visibility)
    const my = sy + POWER_SLIDER_LENGTH * (1 - powerSliderPos);
    const markX = sx - (SLIDER_MARKER_L - SLIDER_THICKNESS) / 2;
    const markY = my - SLIDER_MARKER_T / 2;
    ctx.fillStyle = "#134292";
    ctx.fillRect(markX, markY, SLIDER_MARKER_L, SLIDER_MARKER_T);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#fff";
    ctx.strokeRect(markX, markY, SLIDER_MARKER_L, SLIDER_MARKER_T);

    // Outline
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#999";
    ctx.strokeRect(sx, sy, SLIDER_THICKNESS, POWER_SLIDER_LENGTH);
    ctx.restore();
  }

  function activateBulletTime() {
    if (!bulletTimeAvailable || bulletTimeActive) return;
    bulletTimeAvailable = false;
    bulletTimeActive = true;
    bulletTimeFactor = 0.2;
    if (bulletButtonEl) bulletButtonEl.style.display = 'none';
  }

  // ==== Input ====
  function handleInput(e) {
    if (e.code === 'Space') {
      e.preventDefault();
      switch (state) {
        case STATE_AIM_HORIZONTAL:
          // Lock horizontal offset
          locked_horizontal_offset =
            (horizontalSliderPos - 0.5) * 2 * TARGET_RADIUS_OUTER;
          state = STATE_AIM_VERTICAL;
          break;
        case STATE_AIM_VERTICAL:
          // Lock vertical offset
          locked_vertical_offset =
            (verticalSliderPos - 0.5) * 2 * TARGET_RADIUS_OUTER;
          state = STATE_AIM_POWER;
          break;
        case STATE_AIM_POWER:
          // Lock power, throw!
          locked_power_normalized = powerSliderPos;
          startThrow();
          break;
        case STATE_SHOWING_RESULT:
          if (lastThrowMissed) {
            state = STATE_GAME_OVER;
          } else {
            state = STATE_AIM_HORIZONTAL;
            resetForNextThrow();
          }
          break;
        case STATE_GAME_OVER:
          resetGame();
          state = STATE_AIM_HORIZONTAL;
          break;
      }
    }
  }

  // ==== Throwing Logic ====
  function startThrow() {
    bulletTimeActive = false;
    bulletTimeFactor = 1;
    state = STATE_THROWING;
    axeIsFlying = true;
    axeThrowProgress = 0;
    axeAngle = -AXE_ROTATION_SPEED * axeThrowDuration;

    // Compute target for this throw
    // (Ideal power = minimal vertical deviation. Too low: drop below. Too high: overshoot upward)
    let power_effect_factor = (POWER_IDEAL - locked_power_normalized) * (TARGET_RADIUS_OUTER * 2.0);

    axeTargetX = TARGET_X + locked_horizontal_offset;
    axeTargetY = TARGET_Y + locked_vertical_offset + power_effect_factor;

    // Accuracy: randomness increases as power deviates from ideal
    let power_accuracy_modifier = 1.0 - Math.abs(locked_power_normalized - POWER_IDEAL)/POWER_IDEAL;
    power_accuracy_modifier = Math.max(0, power_accuracy_modifier); // Clamp
    let max_rand = 18 * (1.0 - power_accuracy_modifier**2); // up to 18px if far from ideal
    throw_random_dx = (Math.random()-0.5) * 2 * max_rand;
    throw_random_dy = (Math.random()-0.5) * 2 * max_rand;

    axeHitX = axeTargetX + throw_random_dx;
    axeHitY = axeTargetY + throw_random_dy;
  }

  function evaluateThrow() {
    // Determine where the precise blade tip lands and score based solely on that
    const rotX = axeTipOffsetX * Math.cos(axeAngle) -
                 axeTipOffsetY * Math.sin(axeAngle);
    const rotY = axeTipOffsetX * Math.sin(axeAngle) +
                 axeTipOffsetY * Math.cos(axeAngle);
    const tipX = axeHitX + rotX;
    const tipY = axeHitY + rotY;
    let dx = tipX - TARGET_X;
    let dy = tipY - TARGET_Y;
    let dist = Math.sqrt(dx*dx + dy*dy);

    if (dist <= TARGET_RADIUS_INNER) {
      resultMsg = "Bullseye!";
      resultPoints = 10;
    } else if (dist <= TARGET_RADIUS_MIDDLE) {
      resultMsg = "Great Shot!";
      resultPoints = 7;
    } else if (dist <= TARGET_RADIUS_OUTER) {
      resultMsg = "On Target!";
      resultPoints = 5;
    } else {
      resultMsg = "Missed!";
      resultPoints = 0;
    }
    if (resultPoints > 0) {
      sliderSpeedMultiplier *= 1.2;
      lastThrowMissed = false;
    } else {
      lastThrowMissed = true;
    }
    score += resultPoints;

    showResultTimer = RESULT_SHOW_TIME;
    state = STATE_SHOWING_RESULT;
  }

  // ==== Utilities ====

  function resetGame() {
    score = 0;
    resultMsg = '';
    resultPoints = 0;
    sliderSpeedMultiplier = 1;
    bulletTimeAvailable = true;
    bulletTimeActive = false;
    bulletTimeFactor = 1;
    if (bulletButtonEl) bulletButtonEl.style.display = 'block';
    lastThrowMissed = false;
    resetForNextThrow();
  }
  function resetForNextThrow() {
    horizontalSliderPos = Math.random();
    verticalSliderPos = Math.random();
    powerSliderPos = Math.random();
    horizSliderDir = Math.random() < 0.5 ? 1 : -1;
    vertSliderDir = Math.random() < 0.5 ? 1 : -1;
    powerSliderDir = Math.random() < 0.5 ? 1 : -1;
    locked_horizontal_offset = 0;
    locked_vertical_offset = 0;
    locked_power_normalized = 0;
    axeIsFlying = false;
    axeThrowProgress = 0;
    axeAngle = 0;
    axeHitX = TARGET_X;
    axeHitY = TARGET_Y;
    lastThrowMissed = false;
  }
</script>
</body>
</html>
